import { Router, type Request, type Response } from "express";
import { prisma } from "../db.js";
import { requireAuth } from "../middleware/auth.js";
import { runLighthouseAudit } from "../services/lighthouse.js";

const router: Router = Router();
const AUDIT_COST = 5;

// POST /audit/run
router.post("/run", requireAuth, async (req: Request, res: Response): Promise<void> => {
    const user = (req as any).user;
    const { url } = req.body;

    if (!url) {
        res.status(400).json({ error: "URL is required" });
        return;
    }

    try {
        // 1. Check credits and deduct in a transaction
        await prisma.$transaction(async (tx) => {
            const currentUser = await tx.user.findUniqueOrThrow({
                where: { id: user.id },
            });

            if (currentUser.credits < AUDIT_COST) {
                throw new Error("Insufficient credits");
            }

            await tx.user.update({
                where: { id: user.id },
                data: { credits: { decrement: AUDIT_COST } },
            });

            await tx.transaction.create({
                data: {
                    userId: user.id,
                    amount: -AUDIT_COST,
                    reason: "audit",
                    balanceAfter: currentUser.credits - AUDIT_COST,
                },
            });
        });

        // 2. Run Lighthouse (outside transaction to avoid long-running db locks)
        // Note: If this fails, user loses credits. In production, we'd want a refund mechanism or 
        // run audit first then deduct (risk of free audits) or reserve->commit pattern.
        // For this MVP, we deduct first.
        const auditResult = await runLighthouseAudit(url);

        // 3. Store Result
        const audit = await prisma.audit.create({
            data: {
                userId: user.id,
                url,
                performance: auditResult.performance,
                seo: auditResult.seo,
                accessibility: auditResult.accessibility,
                bestPractices: auditResult.bestPractices,
                lighthouseJson: auditResult.raw,
            },
        });

        // 4. Generate Branded HTML Report
        const reportHtml = `
<div class="cs-report">
  <div class="cs-header">
    <h2>ClearSky Quick Audit Report</h2>
    <p class="cs-url">URL Analyzed: ${url}</p>
  </div>

  <div class="cs-score-section">
    <div class="cs-score-card">
      <span class="label">Performance</span>
      <span class="value">${auditResult.performance}%</span>
    </div>
    <div class="cs-score-card">
      <span class="label">SEO</span>
      <span class="value">${auditResult.seo}%</span>
    </div>
    <div class="cs-score-card">
      <span class="label">Best Practices</span>
      <span class="value">${auditResult.bestPractices}%</span>
    </div>
    <div class="cs-score-card">
      <span class="label">Accessibility</span>
      <span class="value">${auditResult.accessibility}%</span>
    </div>
  </div>

  <div class="cs-overall">
    <h3>Overall Score</h3>
    <p class="score">${Math.round(
            (auditResult.performance +
                auditResult.seo +
                auditResult.bestPractices +
                auditResult.accessibility) /
            4
        )}%</p>
    <p class="explanation">This score reflects Lighthouse-based performance, SEO readiness, accessibility, and technical health.</p>
  </div>
  
  <div class="cs-footer">
    <p>Generated by ClearSky Quick Audit</p>
  </div>
</div>
`;

        // 5. Return Response
        res.json({
            html: reportHtml,
            scores: {
                performance: auditResult.performance,
                seo: auditResult.seo,
                bestPractices: auditResult.bestPractices,
                accessibility: auditResult.accessibility,
            },
            creditsRemaining: user.credits - AUDIT_COST,
        });

    } catch (error: any) {
        if (error.message === "Insufficient credits") {
            res.status(402).json({ error: "Insufficient credits" });
        } else {
            console.error("Audit failed:", error);
            res.status(500).json({ error: "Audit failed to run" });
        }
    }
});

export default router;
